!function(factory) {
	"function" == typeof define && define.amd && define.amd.jQuery ? define(["jquery"], factory) : factory(jQuery)
}
(function($) {
	"use strict";
	function init(options) {
		return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function() {
			var $this = $(this),
				plugin = $this.data(PLUGIN_NS);
			plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin))
		})
	}
	function TouchSwipe(element, options) {
		function touchStart(jqEvent) {
			if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
				var ret, event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
					evt = SUPPORTS_TOUCH ? event.touches[0] : event;
				return phase = PHASE_START, SUPPORTS_TOUCH ? fingerCount = event.touches.length : jqEvent.preventDefault(), distance = 0, direction = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, fingerData = createAllFingerData(), maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), !SUPPORTS_TOUCH || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (createFingerData(0, evt), startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, event.touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (setTouchInProgress(!0), null)
			}
		}
		function touchMove(jqEvent) {
			var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
			if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
				var ret, evt = SUPPORTS_TOUCH ? event.touches[0] : event,
					currentFinger = updateFingerData(evt);
				if (endTime = getTimeStamp(), SUPPORTS_TOUCH && (fingerCount = event.touches.length), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, event.touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(event.touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH || hasPinches()) {
					if (direction = calculateDirection(currentFinger.start, currentFinger.end), validateDefaultEvent(jqEvent, direction), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase)), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
						var inBounds = !0;
						if (options.triggerOnTouchLeave) {
							var bounds = getbounds(this);
							inBounds = isInBounds(currentFinger.end, bounds)
						}!options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), (phase == PHASE_CANCEL || phase == PHASE_END) && triggerHandler(event, phase)
					}
				} else phase = PHASE_CANCEL, triggerHandler(event, phase);
				ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase))
			}
		}
		function touchEnd(jqEvent) {
			var event = jqEvent.originalEvent;
			return SUPPORTS_TOUCH && event.touches.length > 0 ? (startMultiFingerRelease(), !0) : (inMultiFingerRelease() && (fingerCount = previousTouchFingerCount), jqEvent.preventDefault(), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || 0 == options.triggerOnTouchEnd && phase === PHASE_MOVE ? (phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null)
		}
		function touchCancel() {
			fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1)
		}
		function touchLeave(jqEvent) {
			var event = jqEvent.originalEvent;
			options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase))
		}
		function removeListeners() {
			$element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1)
		}
		function getNextPhase(currentPhase) {
			var nextPhase = currentPhase,
				validTime = validateSwipeTime(),
				validDistance = validateSwipeDistance(),
				didCancel = didSwipeBackToCancel();
			return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase
		}
		function triggerHandler(event, phase) {
			var ret = void 0;
			return didSwipe() || hasSwipes() ? ret = triggerHandlerForGesture(event, phase, SWIPE) : (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (SUPPORTS_TOUCH ? 0 == event.touches.length && touchCancel(event) : touchCancel(event)), ret
		}
		function triggerHandlerForGesture(event, phase, gesture) {
			var ret = void 0;
			if (gesture == SWIPE) {
				if ($element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount), ret === !1)) return !1;
				if (phase == PHASE_END && validateSwipe()) {
					if ($element.trigger("swipe", [direction, distance, duration, fingerCount]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount), ret === !1)) return !1;
					switch (direction) {
					case LEFT:
						$element.trigger("swipeLeft", [direction, distance, duration, fingerCount]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount));
						break;
					case RIGHT:
						$element.trigger("swipeRight", [direction, distance, duration, fingerCount]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount));
						break;
					case UP:
						$element.trigger("swipeUp", [direction, distance, duration, fingerCount]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount));
						break;
					case DOWN:
						$element.trigger("swipeDown", [direction, distance, duration, fingerCount]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount))
					}
				}
			}
			if (gesture == PINCH) {
				if ($element.trigger("pinchStatus", [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom), ret === !1)) return !1;
				if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
				case IN:
					$element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom));
					break;
				case OUT:
					$element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom))
				}
			}
			return gesture == TAP ? (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function() {
				doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target))
			}, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("doubletap", [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("longtap", [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target))), ret
		}
		function validateSwipeDistance() {
			var valid = !0;
			return null !== options.threshold && (valid = distance >= options.threshold), valid
		}
		function didSwipeBackToCancel() {
			var cancelled = !1;
			return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled
		}
		function validatePinchDistance() {
			return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0
		}
		function validateSwipeTime() {
			var result;
			return result = options.maxTimeThreshold ? duration >= options.maxTimeThreshold ? !1 : !0 : !0
		}
		function validateDefaultEvent(jqEvent, direction) {
			if (options.allowPageScroll === NONE || hasPinches()) jqEvent.preventDefault();
			else {
				var auto = options.allowPageScroll === AUTO;
				switch (direction) {
				case LEFT:
					(options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
					break;
				case RIGHT:
					(options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
					break;
				case UP:
					(options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
					break;
				case DOWN:
					(options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault()
				}
			}
		}
		function validatePinch() {
			var hasCorrectFingerCount = validateFingers(),
				hasEndPoint = validateEndPoint(),
				hasCorrectDistance = validatePinchDistance();
			return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance
		}
		function hasPinches() {
			return !!(options.pinchStatus || options.pinchIn || options.pinchOut)
		}
		function didPinch() {
			return !(!validatePinch() || !hasPinches())
		}
		function validateSwipe() {
			var hasValidTime = validateSwipeTime(),
				hasValidDistance = validateSwipeDistance(),
				hasCorrectFingerCount = validateFingers(),
				hasEndPoint = validateEndPoint(),
				didCancel = didSwipeBackToCancel(),
				valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
			return valid
		}
		function hasSwipes() {
			return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown)
		}
		function didSwipe() {
			return !(!validateSwipe() || !hasSwipes())
		}
		function validateFingers() {
			return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH
		}
		function validateEndPoint() {
			return 0 !== fingerData[0].end.x
		}
		function hasTap() {
			return !!options.tap
		}
		function hasDoubleTap() {
			return !!options.doubleTap
		}
		function hasLongTap() {
			return !!options.longTap
		}
		function validateDoubleTap() {
			if (null == doubleTapStartTime) return !1;
			var now = getTimeStamp();
			return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold
		}
		function inDoubleTap() {
			return validateDoubleTap()
		}
		function validateTap() {
			return !(1 !== fingerCount && SUPPORTS_TOUCH || !isNaN(distance) && 0 !== distance)
		}
		function validateLongTap() {
			return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance
		}
		function didTap() {
			return !(!validateTap() || !hasTap())
		}
		function didDoubleTap() {
			return !(!validateDoubleTap() || !hasDoubleTap())
		}
		function didLongTap() {
			return !(!validateLongTap() || !hasLongTap())
		}
		function startMultiFingerRelease() {
			previousTouchEndTime = getTimeStamp(), previousTouchFingerCount = event.touches.length + 1
		}
		function cancelMultiFingerRelease() {
			previousTouchEndTime = 0, previousTouchFingerCount = 0
		}
		function inMultiFingerRelease() {
			var withinThreshold = !1;
			if (previousTouchEndTime) {
				var diff = getTimeStamp() - previousTouchEndTime;
				diff <= options.fingerReleaseThreshold && (withinThreshold = !0)
			}
			return withinThreshold
		}
		function getTouchInProgress() {
			return !($element.data(PLUGIN_NS + "_intouch") !== !0)
		}
		function setTouchInProgress(val) {
			val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + "_intouch", val === !0)
		}
		function createFingerData(index, evt) {
			var id = void 0 !== evt.identifier ? evt.identifier : 0;
			return fingerData[index].identifier = id, fingerData[index].start.x = fingerData[index].end.x = evt.pageX || evt.clientX, fingerData[index].start.y = fingerData[index].end.y = evt.pageY || evt.clientY, fingerData[index]
		}
		function updateFingerData(evt) {
			var id = void 0 !== evt.identifier ? evt.identifier : 0,
				f = getFingerData(id);
			return f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f
		}
		function getFingerData(id) {
			for (var i = 0; i < fingerData.length; i++) if (fingerData[i].identifier == id) return fingerData[i]
		}
		function createAllFingerData() {
			for (var fingerData = [], i = 0; 5 >= i; i++) fingerData.push({
				start: {
					x: 0,
					y: 0
				},
				end: {
					x: 0,
					y: 0
				},
				identifier: 0
			});
			return fingerData
		}
		function setMaxDistance(direction, distance) {
			distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance
		}
		function getMaxDistance(direction) {
			return maximumsMap[direction] ? maximumsMap[direction].distance : void 0
		}
		function createMaximumsData() {
			var maxData = {};
			return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData
		}
		function createMaximumVO(dir) {
			return {
				direction: dir,
				distance: 0
			}
		}
		function calculateDuration() {
			return endTime - startTime
		}
		function calculateTouchesDistance(startPoint, endPoint) {
			var diffX = Math.abs(startPoint.x - endPoint.x),
				diffY = Math.abs(startPoint.y - endPoint.y);
			return Math.round(Math.sqrt(diffX * diffX + diffY * diffY))
		}
		function calculatePinchZoom(startDistance, endDistance) {
			var percent = endDistance / startDistance * 1;
			return percent.toFixed(2)
		}
		function calculatePinchDirection() {
			return 1 > pinchZoom ? OUT : IN
		}
		function calculateDistance(startPoint, endPoint) {
			return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)))
		}
		function calculateAngle(startPoint, endPoint) {
			var x = startPoint.x - endPoint.x,
				y = endPoint.y - startPoint.y,
				r = Math.atan2(y, x),
				angle = Math.round(180 * r / Math.PI);
			return 0 > angle && (angle = 360 - Math.abs(angle)), angle
		}
		function calculateDirection(startPoint, endPoint) {
			var angle = calculateAngle(startPoint, endPoint);
			return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP
		}
		function getTimeStamp() {
			var now = new Date;
			return now.getTime()
		}
		function getbounds(el) {
			el = $(el);
			var offset = el.offset(),
				bounds = {
					left: offset.left,
					right: offset.left + el.outerWidth(),
					top: offset.top,
					bottom: offset.top + el.outerHeight()
				};
			return bounds
		}
		function isInBounds(point, bounds) {
			return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom
		}
		var useTouchEvents = SUPPORTS_TOUCH || !options.fallbackToMouseEvents,
			START_EV = useTouchEvents ? "touchstart" : "mousedown",
			MOVE_EV = useTouchEvents ? "touchmove" : "mousemove",
			END_EV = useTouchEvents ? "touchend" : "mouseup",
			LEAVE_EV = useTouchEvents ? null : "mouseleave",
			CANCEL_EV = "touchcancel",
			distance = 0,
			direction = null,
			duration = 0,
			startTouchesDistance = 0,
			endTouchesDistance = 0,
			pinchZoom = 1,
			pinchDistance = 0,
			pinchDirection = 0,
			maximumsMap = null,
			$element = $(element),
			phase = "start",
			fingerCount = 0,
			fingerData = null,
			startTime = 0,
			endTime = 0,
			previousTouchEndTime = 0,
			previousTouchFingerCount = 0,
			doubleTapStartTime = 0,
			singleTapTimeout = null;
		try {
			$element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel)
		} catch (e) {
			$.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe")
		}
		this.enable = function() {
			return $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element
		}, this.disable = function() {
			return removeListeners(), $element
		}, this.destroy = function() {
			return removeListeners(), $element.data(PLUGIN_NS, null), $element
		}, this.option = function(property, value) {
			if (void 0 !== options[property]) {
				if (void 0 === value) return options[property];
				options[property] = value
			} else $.error("Option " + property + " does not exist on jQuery.swipe.options");
			return null
		}
	}
	var LEFT = "left",
		RIGHT = "right",
		UP = "up",
		DOWN = "down",
		IN = "in",
		OUT = "out",
		NONE = "none",
		AUTO = "auto",
		SWIPE = "swipe",
		PINCH = "pinch",
		TAP = "tap",
		DOUBLE_TAP = "doubletap",
		LONG_TAP = "longtap",
		HORIZONTAL = "horizontal",
		VERTICAL = "vertical",
		ALL_FINGERS = "all",
		DOUBLE_TAP_THRESHOLD = 10,
		PHASE_START = "start",
		PHASE_MOVE = "move",
		PHASE_END = "end",
		PHASE_CANCEL = "cancel",
		SUPPORTS_TOUCH = "ontouchstart" in window,
		PLUGIN_NS = "TouchSwipe",
		defaults = {
			fingers: 1,
			threshold: 75,
			cancelThreshold: null,
			pinchThreshold: 20,
			maxTimeThreshold: null,
			fingerReleaseThreshold: 250,
			longTapThreshold: 500,
			doubleTapThreshold: 200,
			swipe: null,
			swipeLeft: null,
			swipeRight: null,
			swipeUp: null,
			swipeDown: null,
			swipeStatus: null,
			pinchIn: null,
			pinchOut: null,
			pinchStatus: null,
			click: null,
			tap: null,
			doubleTap: null,
			longTap: null,
			triggerOnTouchEnd: !0,
			triggerOnTouchLeave: !1,
			allowPageScroll: "auto",
			fallbackToMouseEvents: !0,
			excludedElements: "label, button, input, select, textarea, a, .noSwipe"
		};
	$.fn.swipe = function(method) {
		var $this = $(this),
			plugin = $this.data(PLUGIN_NS);
		if (plugin && "string" == typeof method) {
			if (plugin[method]) return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
			$.error("Method " + method + " does not exist on jQuery.swipe")
		} else if (!(plugin || "object" != typeof method && method)) return init.apply(this, arguments);
		return $this
	}, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
		PHASE_START: PHASE_START,
		PHASE_MOVE: PHASE_MOVE,
		PHASE_END: PHASE_END,
		PHASE_CANCEL: PHASE_CANCEL
	}, $.fn.swipe.directions = {
		LEFT: LEFT,
		RIGHT: RIGHT,
		UP: UP,
		DOWN: DOWN,
		IN: IN,
		OUT: OUT
	}, $.fn.swipe.pageScroll = {
		NONE: NONE,
		HORIZONTAL: HORIZONTAL,
		VERTICAL: VERTICAL,
		AUTO: AUTO
	}, $.fn.swipe.fingers = {
		ONE: 1,
		TWO: 2,
		THREE: 3,
		ALL: ALL_FINGERS
	}
});

function init_scroll(event, delta) {
	var deltaOfInterest = delta,
		timeNow = (new Date).getTime();
	return quietPeriod + animationTime > timeNow - lastAnimation ? (event.preventDefault(), void 0) : (0 > deltaOfInterest ? moveDown(currSlide.id) : moveUp(currSlide.id), lastAnimation = timeNow, void 0)
}
function moveDown(slide) {
	slide + 1 != $fixedContainer.length && (slideToGo = slide + 1, animateWindow(slideToGo))
}
function moveUp(slide) {
	0 >= slide || (slideToGo = slide - 1, animateWindow(slideToGo))
}
function animateWindow(slide, customTime) {
	$("html,body").stop().animate({
		scrollTop: $fixedContainer.eq(slide).offset().top
	}, "undefined" != typeof customTime ? customTime : animationTime, "swing", function() {
		if (Modernizr.touch) try {
			repaintScreen()
		} catch (err) {}
	})
}
function checkVisibility() {
	$fixedContainer.each(function(i, el) {
		$(el).visible(!0) ? (0 == currSlide.found ? (currSlide.id = i, currSlide.found = !0, $fixed.eq(i).addClass("active-slide"), $navigation.find("a").eq(i).addClass("loc")) : ($fixed.eq(i).removeClass("active-slide"), $navigation.find("a").eq(i).removeClass("loc")), $fixed.eq(i).removeClass("come-out")) : ($fixed.eq(i).addClass("come-out"), $fixed.eq(i).removeClass("active-slide"), $navigation.find("a").eq(i).removeClass("loc"))
	})
}
function resetCurrSlide() {
	currSlide = {
		id: 0,
		found: !1
	}
}
function initHomepageScroll() {
	showHomePageContect(), $(".homepage-blur-container").removeClass("blur"), window.setTimeout(checkVisibility, 20), $(window).on("scrollstop", function() {
		resetCurrSlide(), checkVisibility()
	}), $(document).on("DOMMouseScroll mousewheel wheel", function(event) {
		event.preventDefault();
		var delta = event.originalEvent.wheelDelta || -event.originalEvent.detail || 2 * -event.originalEvent.deltaY;
		init_scroll(event, delta)
	}), $(document).swipe({
		swipe: function(event, direction) {
			"up" == direction ? moveDown(currSlide.id) : "down" == direction && moveUp(currSlide.id)
		},
		threshold: 100
	}), $navigation.find("a").click(function() {
		var index = $(this).index();
		animateWindow(index, 0)
	}), $navigation.find("a").eq(0).trigger("click"), $(window).on("resize load orientationchange", function() {
		wHeight = $(window).height(), $fixedContainer.each(function() {
			$(this).height(1.1 * wHeight)
		}), $fixedContainer.height(wHeight), $fixed.height(wHeight), resetCurrSlide(), checkVisibility()
	}), Modernizr.touch && ($(".container").on("webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend", function() {
		$("#device").css("height", "200px"), $("a, .homepage-horizontal-arrow").removeClass("activeClick"), setTimeout(function() {
			$("#device").css("height", "0px"), $("a, .homepage-horizontal-arrow").addClass("activeClick").hide().show()
		}, 10)
	}), $("body").delegate(".homepage-horizontal-arrow", "touchstart", function(e) {
		$(this).trigger("click"), e.preventDefault(), e.stopImmediatePropagation()
	}), $(".cycle-slideshow").addClass("noSwipe"))
}!
function($) {
	$.fn.visible = function(partial) {
		var $t = $(this),
			$w = $(window),
			viewTop = $w.scrollTop(),
			_top = (viewTop + $w.height(), $t.offset().top),
			_bottom = _top + $t.height(),
			compareTop = partial === !0 ? _bottom : _top;
		return compareTop >= viewTop && compareTop > viewTop + 1
	}
}($), function() {
	var special = jQuery.event.special,
		uid1 = "D" + +new Date,
		uid2 = "D" + (+new Date + 1),
		mouseDown = !1,
		latency = 300;
	special.scrollstart = {
		setup: function() {
			var timer, clearTimer = function() {
					timer = null
				},
				handler = function() {
					timer ? clearTimeout(timer) : jQuery.event.simulate("scrollstart", this, arguments), timer = setTimeout(mouseDown ? handler : clearTimer, latency)
				};
			jQuery(this).on("scroll", handler).data(uid1, handler)
		},
		teardown: function() {
			jQuery(this).off("scroll mousedown mouseup", jQuery(this).data(uid1))
		}
	}, special.scrollstop = {
		setup: function() {
			var timer, clearTimer = function() {
					timer = null
				},
				handler = function() {
					timer && clearTimeout(timer), timer = setTimeout(mouseDown ? handler : function() {
						clearTimer(), jQuery.event.simulate("scrollstop", this, arguments)
					}, latency)
				};
			jQuery(this).on("scroll", handler).data(uid2, handler)
		},
		teardown: function() {
			jQuery(this).off("scroll", jQuery(this).data(uid2))
		}
	}, jQuery(this).on("mousedown", function() {
		mouseDown = !0
	}).on("mouseup", function() {
		mouseDown = !1
	})
}();
var $fixed = $(".main-section .container"),
	$fixedContainer = $(".main-section"),
	lastAnimation = 0,
	quietPeriod = 1e3,
	animationTime = 0,
	currSlide = {
		id: 0,
		found: !1
	};
!
function(window, document) {
	function _addWheelListener(elem, eventName, callback, useCapture) {
		elem[_addEventListener](prefix + eventName, "wheel" == support ? callback : function(originalEvent) {
			!originalEvent && (originalEvent = window.event);
			var event = {
				originalEvent: originalEvent,
				target: originalEvent.target || originalEvent.srcElement,
				type: "wheel",
				deltaMode: "MozMousePixelScroll" == originalEvent.type ? 0 : 1,
				deltaX: 0,
				deltaZ: 0,
				preventDefault: function() {
					originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = !1
				}
			};
			return "mousewheel" == support ? (event.deltaY = -1 / 40 * originalEvent.wheelDelta, originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX)) : event.deltaY = originalEvent.detail, callback(event)
		}, useCapture || !1)
	}
	var _addEventListener, support, prefix = "";
	window.addEventListener ? _addEventListener = "addEventListener" : (_addEventListener = "attachEvent", prefix = "on"), support = "onwheel" in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll", window.addWheelListener = function(elem, callback, useCapture) {
		_addWheelListener(elem, support, callback, useCapture), "DOMMouseScroll" == support && _addWheelListener(elem, "MozMousePixelScroll", callback, useCapture)
	}
}(window, document);